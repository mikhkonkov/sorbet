digraph "for.rb" {
subgraph "cluster_::<Class:<root>>#<static-init>" {
    label = "::<Class:<root>>#<static-init>";
    color = blue;
    "bb::<Class:<root>>#<static-init>_0" [shape = invhouse];
    "bb::<Class:<root>>#<static-init>_1" [shape = parallelogram];

    "bb::<Class:<root>>#<static-init>_0" [
        label = "block[id=0]()\l<self>: T.class_of(<root>) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U <root>>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U <root>>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<statTemp>$5: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<statTemp>$6: T.class_of(A) = alias <C A>\l<statTemp>$4: Sorbet::Private::Static::Void = <statTemp>$5: T.class_of(Sorbet::Private::Static).keep_for_ide(<statTemp>$6: T.class_of(A))\l<statTemp>$9: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<statTemp>$10: T.class_of(E) = alias <C E>\l<statTemp>$8: Sorbet::Private::Static::Void = <statTemp>$9: T.class_of(Sorbet::Private::Static).keep_for_ide(<statTemp>$10: T.class_of(E))\l<statTemp>$13: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<statTemp>$14: T.class_of(Main) = alias <C Main>\l<statTemp>$12: Sorbet::Private::Static::Void = <statTemp>$13: T.class_of(Sorbet::Private::Static).keep_for_ide(<statTemp>$14: T.class_of(Main))\l<statTemp>$16: T.class_of(Main) = alias <C Main>\l<statTemp>$15: T.untyped = <statTemp>$16: T.class_of(Main).main()\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_0" -> "bb::<Class:<root>>#<static-init>_1" [style="bold"];
    "bb::<Class:<root>>#<static-init>_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_1" -> "bb::<Class:<root>>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::<Class:A>#each" {
    label = "::<Class:A>#each";
    color = blue;
    "bb::<Class:A>#each_0" [shape = invhouse];
    "bb::<Class:A>#each_1" [shape = parallelogram];

    "bb::<Class:A>#each_0" [
        label = "block[id=0]()\l<self>: T.class_of(A) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U A>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U A>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<blk>: T.untyped = load_arg(<blk>)\l<statTemp>$5: Integer(1) = 1\l<statTemp>$6: Integer(2) = 2\l<statTemp>$7: Integer(3) = 3\l<statTemp>$8: Integer(4) = 4\l<statTemp>$9: Integer(5) = 5\l<statTemp>$3: T.untyped = <blk>: T.untyped.call(<statTemp>$5: Integer(1), <statTemp>$6: Integer(2), <statTemp>$7: Integer(3), <statTemp>$8: Integer(4), <statTemp>$9: Integer(5))\l<statTemp>$11: Integer(6) = 6\l<statTemp>$12: Integer(7) = 7\l<statTemp>$13: Integer(8) = 8\l<statTemp>$14: Integer(9) = 9\l<statTemp>$15: Integer(0) = 0\l<returnMethodTemp>$2: T.untyped = <blk>: T.untyped.call(<statTemp>$11: Integer(6), <statTemp>$12: Integer(7), <statTemp>$13: Integer(8), <statTemp>$14: Integer(9), <statTemp>$15: Integer(0))\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::<Class:A>#each_0" -> "bb::<Class:A>#each_1" [style="bold"];
    "bb::<Class:A>#each_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:A>#each_1" -> "bb::<Class:A>#each_1" [style="bold"];
}

subgraph "cluster_::<Class:E>#e=" {
    label = "::<Class:E>#e=";
    color = blue;
    "bb::<Class:E>#e=_0" [shape = invhouse];
    "bb::<Class:E>#e=_1" [shape = parallelogram];

    "bb::<Class:E>#e=_0" [
        label = "block[id=0]()\l@e$3: T.untyped = alias <C <undeclared-field-stub>>\l<self>: T.class_of(E) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U E>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U E>> $1><C <U <AttachedClass>>>)\l  ]\l});\le: T.untyped = load_arg(e)\l@e$3: T.untyped = e\l<returnMethodTemp>$2: T.untyped = @e$3\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::<Class:E>#e=_0" -> "bb::<Class:E>#e=_1" [style="bold"];
    "bb::<Class:E>#e=_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:E>#e=_1" -> "bb::<Class:E>#e=_1" [style="bold"];
}

subgraph "cluster_::<Class:E>#e" {
    label = "::<Class:E>#e";
    color = blue;
    "bb::<Class:E>#e_0" [shape = invhouse];
    "bb::<Class:E>#e_1" [shape = parallelogram];

    "bb::<Class:E>#e_0" [
        label = "block[id=0]()\l@e$3: T.untyped = alias <C <undeclared-field-stub>>\l<self>: T.class_of(E) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U E>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U E>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<returnMethodTemp>$2: T.untyped = @e$3\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::<Class:E>#e_0" -> "bb::<Class:E>#e_1" [style="bold"];
    "bb::<Class:E>#e_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:E>#e_1" -> "bb::<Class:E>#e_1" [style="bold"];
}

subgraph "cluster_::<Class:Main>#main" {
    label = "::<Class:Main>#main";
    color = blue;
    "bb::<Class:Main>#main_0" [shape = invhouse];
    "bb::<Class:Main>#main_1" [shape = parallelogram];

    "bb::<Class:Main>#main_0" [
        label = "block[id=0]()\l@a$121: T.untyped = alias <C <undeclared-field-stub>>\l@@b$125: T.untyped = alias <C <undeclared-field-stub>>\l$c$129: T.untyped = alias $c\l<self>: T.class_of(Main) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U Main>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Main>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<statTemp>$4: T.class_of(A) = alias <C A>\l<block-pre-call-temp>$5: Sorbet::Private::Static::Void = <statTemp>$4: T.class_of(A).each()\l<selfRestore>$6: T.class_of(Main) = <self>\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_0" -> "bb::<Class:Main>#main_2" [style="bold"];
    "bb::<Class:Main>#main_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_1" -> "bb::<Class:Main>#main_1" [style="bold"];
    "bb::<Class:Main>#main_2" [
        label = "block[id=2](<self>: T.class_of(Main), <selfRestore>$6: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:Main>#main_2" -> "bb::<Class:Main>#main_5" [style="bold"];
    "bb::<Class:Main>#main_2" -> "bb::<Class:Main>#main_3" [style="tapered"];

    "bb::<Class:Main>#main_3" [
        label = "block[id=3](<selfRestore>$6: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\l<statTemp>$3: T.untyped = Solve<each>\l<self>: T.class_of(Main) = <selfRestore>$6\l<statTemp>$25: T.class_of(A) = alias <C A>\l<block-pre-call-temp>$26: Sorbet::Private::Static::Void = <statTemp>$25: T.class_of(A).each()\l<selfRestore>$27: T.class_of(Main) = <self>\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_3" -> "bb::<Class:Main>#main_6" [style="bold"];
    "bb::<Class:Main>#main_5" [
        label = "block[id=5](<self>: T.class_of(Main), <selfRestore>$6: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\louterLoops: 1\l<self>: T.class_of(Main) = loadSelf\l<blk>$7: T.untyped = load_yield_params(each)\l<statTemp>$13: T.class_of(<Magic>) = alias <C <Magic>>\l<statTemp>$15: Integer(1) = 1\l<statTemp>$16: Integer(0) = 0\l<assignTemp>$4$1: T.untyped = <statTemp>$13: T.class_of(<Magic>).<expand-splat>(<blk>$7: T.untyped, <statTemp>$15: Integer(1), <statTemp>$16: Integer(0))\l<statTemp>$19: Integer(0) = 0\la$1: T.untyped = <assignTemp>$4$1: T.untyped.[](<statTemp>$19: Integer(0))\l<statTemp>$21: T.untyped = a$1: T.untyped.inspect()\l<blockReturnTemp>$9: NilClass = <self>: T.class_of(Main).puts(<statTemp>$21: T.untyped)\l<blockReturnTemp>$23: T.noreturn = blockreturn<each> <blockReturnTemp>$9: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_5" -> "bb::<Class:Main>#main_2" [style="bold"];
    "bb::<Class:Main>#main_6" [
        label = "block[id=6](<self>: T.class_of(Main), <selfRestore>$27: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:Main>#main_6" -> "bb::<Class:Main>#main_9" [style="bold"];
    "bb::<Class:Main>#main_6" -> "bb::<Class:Main>#main_7" [style="tapered"];

    "bb::<Class:Main>#main_7" [
        label = "block[id=7](<selfRestore>$27: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\l<statTemp>$24: T.untyped = Solve<each>\l<self>: T.class_of(Main) = <selfRestore>$27\l<statTemp>$47: T.class_of(A) = alias <C A>\l<block-pre-call-temp>$48: Sorbet::Private::Static::Void = <statTemp>$47: T.class_of(A).each()\l<selfRestore>$49: T.class_of(Main) = <self>\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_7" -> "bb::<Class:Main>#main_10" [style="bold"];
    "bb::<Class:Main>#main_9" [
        label = "block[id=9](<self>: T.class_of(Main), <selfRestore>$27: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\louterLoops: 1\l<self>: T.class_of(Main) = loadSelf\l<blk>$28: T.untyped = load_yield_params(each)\lforTemp$2: T.untyped = <blk>$28\l<assignTemp>$5$2: T.untyped = forTemp$2: T.untyped.to_a()\l<statTemp>$35: T.class_of(<Magic>) = alias <C <Magic>>\l<statTemp>$37: Integer(1) = 1\l<statTemp>$38: Integer(0) = 0\l<assignTemp>$6$2: T.untyped = <statTemp>$35: T.class_of(<Magic>).<expand-splat>(<assignTemp>$5$2: T.untyped, <statTemp>$37: Integer(1), <statTemp>$38: Integer(0))\l<statTemp>$41: Integer(0) = 0\la$2: T.untyped = <assignTemp>$6$2: T.untyped.[](<statTemp>$41: Integer(0))\l<statTemp>$43: T.untyped = a$2: T.untyped.inspect()\l<blockReturnTemp>$30: NilClass = <self>: T.class_of(Main).puts(<statTemp>$43: T.untyped)\l<blockReturnTemp>$45: T.noreturn = blockreturn<each> <blockReturnTemp>$30: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_9" -> "bb::<Class:Main>#main_6" [style="bold"];
    "bb::<Class:Main>#main_10" [
        label = "block[id=10](<self>: T.class_of(Main), <selfRestore>$49: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:Main>#main_10" -> "bb::<Class:Main>#main_13" [style="bold"];
    "bb::<Class:Main>#main_10" -> "bb::<Class:Main>#main_11" [style="tapered"];

    "bb::<Class:Main>#main_11" [
        label = "block[id=11](<selfRestore>$49: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\l<statTemp>$46: T.untyped = Solve<each>\l<self>: T.class_of(Main) = <selfRestore>$49\l<statTemp>$75: T.class_of(A) = alias <C A>\l<block-pre-call-temp>$76: Sorbet::Private::Static::Void = <statTemp>$75: T.class_of(A).each()\l<selfRestore>$77: T.class_of(Main) = <self>\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_11" -> "bb::<Class:Main>#main_14" [style="bold"];
    "bb::<Class:Main>#main_13" [
        label = "block[id=13](<self>: T.class_of(Main), <selfRestore>$49: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\louterLoops: 1\l<self>: T.class_of(Main) = loadSelf\l<blk>$50: T.untyped = load_yield_params(each)\l<statTemp>$56: T.class_of(<Magic>) = alias <C <Magic>>\l<statTemp>$58: Integer(2) = 2\l<statTemp>$59: Integer(0) = 0\l<assignTemp>$9$3: T.untyped = <statTemp>$56: T.class_of(<Magic>).<expand-splat>(<blk>$50: T.untyped, <statTemp>$58: Integer(2), <statTemp>$59: Integer(0))\l<statTemp>$62: Integer(0) = 0\la$3: T.untyped = <assignTemp>$9$3: T.untyped.[](<statTemp>$62: Integer(0))\l<statTemp>$65: Integer(1) = 1\lb$3: T.untyped = <assignTemp>$9$3: T.untyped.[](<statTemp>$65: Integer(1))\l<statTemp>$68: T.untyped = a$3: T.untyped.inspect()\l<statTemp>$66: NilClass = <self>: T.class_of(Main).puts(<statTemp>$68: T.untyped)\l<statTemp>$71: T.untyped = b$3: T.untyped.inspect()\l<blockReturnTemp>$52: NilClass = <self>: T.class_of(Main).puts(<statTemp>$71: T.untyped)\l<blockReturnTemp>$73: T.noreturn = blockreturn<each> <blockReturnTemp>$52: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_13" -> "bb::<Class:Main>#main_10" [style="bold"];
    "bb::<Class:Main>#main_14" [
        label = "block[id=14](<self>: T.class_of(Main), <selfRestore>$77: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:Main>#main_14" -> "bb::<Class:Main>#main_17" [style="bold"];
    "bb::<Class:Main>#main_14" -> "bb::<Class:Main>#main_15" [style="tapered"];

    "bb::<Class:Main>#main_15" [
        label = "block[id=15](<selfRestore>$77: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\l<statTemp>$74: T.untyped = Solve<each>\l<self>: T.class_of(Main) = <selfRestore>$77\l<statTemp>$105: String(\"main\") = \"main\"\l<statTemp>$103: NilClass = <self>: T.class_of(Main).puts(<statTemp>$105: String(\"main\"))\l<statTemp>$107: T.class_of(A) = alias <C A>\l<block-pre-call-temp>$108: Sorbet::Private::Static::Void = <statTemp>$107: T.class_of(A).each()\l<selfRestore>$109: T.class_of(Main) = <self>\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_15" -> "bb::<Class:Main>#main_18" [style="bold"];
    "bb::<Class:Main>#main_17" [
        label = "block[id=17](<self>: T.class_of(Main), <selfRestore>$77: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\louterLoops: 1\l<self>: T.class_of(Main) = loadSelf\l<blk>$78: T.untyped = load_yield_params(each)\lforTemp$4: T.untyped = <blk>$78\l<assignTemp>$10$4: T.untyped = forTemp$4: T.untyped.to_a()\l<statTemp>$85: T.class_of(<Magic>) = alias <C <Magic>>\l<statTemp>$87: Integer(2) = 2\l<statTemp>$88: Integer(0) = 0\l<assignTemp>$11$4: T.untyped = <statTemp>$85: T.class_of(<Magic>).<expand-splat>(<assignTemp>$10$4: T.untyped, <statTemp>$87: Integer(2), <statTemp>$88: Integer(0))\l<statTemp>$91: Integer(0) = 0\la$4: T.untyped = <assignTemp>$11$4: T.untyped.[](<statTemp>$91: Integer(0))\l<statTemp>$94: Integer(1) = 1\lb$4: T.untyped = <assignTemp>$11$4: T.untyped.[](<statTemp>$94: Integer(1))\l<statTemp>$97: T.untyped = a$4: T.untyped.inspect()\l<statTemp>$95: NilClass = <self>: T.class_of(Main).puts(<statTemp>$97: T.untyped)\l<statTemp>$100: T.untyped = b$4: T.untyped.inspect()\l<blockReturnTemp>$80: NilClass = <self>: T.class_of(Main).puts(<statTemp>$100: T.untyped)\l<blockReturnTemp>$102: T.noreturn = blockreturn<each> <blockReturnTemp>$80: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_17" -> "bb::<Class:Main>#main_14" [style="bold"];
    "bb::<Class:Main>#main_18" [
        label = "block[id=18](<self>: T.class_of(Main), <selfRestore>$109: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:Main>#main_18" -> "bb::<Class:Main>#main_21" [style="bold"];
    "bb::<Class:Main>#main_18" -> "bb::<Class:Main>#main_19" [style="tapered"];

    "bb::<Class:Main>#main_19" [
        label = "block[id=19](<selfRestore>$109: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\l<statTemp>$106: T.untyped = Solve<each>\l<self>: T.class_of(Main) = <selfRestore>$109\l<statTemp>$161: T.class_of(A) = alias <C A>\l<block-pre-call-temp>$162: Sorbet::Private::Static::Void = <statTemp>$161: T.class_of(A).each()\l<selfRestore>$163: T.class_of(Main) = <self>\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_19" -> "bb::<Class:Main>#main_22" [style="bold"];
    "bb::<Class:Main>#main_21" [
        label = "block[id=21](<self>: T.class_of(Main), <selfRestore>$109: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\louterLoops: 1\l<self>: T.class_of(Main) = loadSelf\l<blk>$110: T.untyped = load_yield_params(each)\l<statTemp>$116: T.class_of(<Magic>) = alias <C <Magic>>\l<statTemp>$118: Integer(5) = 5\l<statTemp>$119: Integer(0) = 0\l<assignTemp>$14$5: T.untyped = <statTemp>$116: T.class_of(<Magic>).<expand-splat>(<blk>$110: T.untyped, <statTemp>$118: Integer(5), <statTemp>$119: Integer(0))\l<statTemp>$123: Integer(0) = 0\l@a$121: T.untyped = <assignTemp>$14$5: T.untyped.[](<statTemp>$123: Integer(0))\l<statTemp>$127: Integer(1) = 1\l@@b$125: T.untyped = <assignTemp>$14$5: T.untyped.[](<statTemp>$127: Integer(1))\l<statTemp>$131: Integer(2) = 2\l$c$129: T.untyped = <assignTemp>$14$5: T.untyped.[](<statTemp>$131: Integer(2))\l<statTemp>$134: Integer(3) = 3\ld$5: T.untyped = <assignTemp>$14$5: T.untyped.[](<statTemp>$134: Integer(3))\l<statTemp>$136: T.class_of(E) = alias <C E>\l<statTemp>$139: Integer(4) = 4\l<statTemp>$137: T.untyped = <assignTemp>$14$5: T.untyped.[](<statTemp>$139: Integer(4))\l<statTemp>$135: T.untyped = <statTemp>$136: T.class_of(E).e=(<statTemp>$137: T.untyped)\l<statTemp>$142: T.untyped = @a$121: T.untyped.inspect()\l<statTemp>$140: NilClass = <self>: T.class_of(Main).puts(<statTemp>$142: T.untyped)\l<statTemp>$146: T.untyped = @@b$125: T.untyped.inspect()\l<statTemp>$144: NilClass = <self>: T.class_of(Main).puts(<statTemp>$146: T.untyped)\l<statTemp>$150: T.untyped = $c$129: T.untyped.inspect()\l<statTemp>$148: NilClass = <self>: T.class_of(Main).puts(<statTemp>$150: T.untyped)\l<statTemp>$154: T.untyped = d$5: T.untyped.inspect()\l<statTemp>$152: NilClass = <self>: T.class_of(Main).puts(<statTemp>$154: T.untyped)\l<statTemp>$159: T.class_of(E) = alias <C E>\l<statTemp>$158: T.untyped = <statTemp>$159: T.class_of(E).e()\l<statTemp>$157: T.untyped = <statTemp>$158: T.untyped.inspect()\l<blockReturnTemp>$112: NilClass = <self>: T.class_of(Main).puts(<statTemp>$157: T.untyped)\l<blockReturnTemp>$160: T.noreturn = blockreturn<each> <blockReturnTemp>$112: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_21" -> "bb::<Class:Main>#main_18" [style="bold"];
    "bb::<Class:Main>#main_22" [
        label = "block[id=22](<self>: T.class_of(Main), <selfRestore>$163: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:Main>#main_22" -> "bb::<Class:Main>#main_25" [style="bold"];
    "bb::<Class:Main>#main_22" -> "bb::<Class:Main>#main_23" [style="tapered"];

    "bb::<Class:Main>#main_23" [
        label = "block[id=23](<selfRestore>$163: T.class_of(Main))\l<returnMethodTemp>$2: T.untyped = Solve<each>\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_23" -> "bb::<Class:Main>#main_1" [style="bold"];
    "bb::<Class:Main>#main_25" [
        label = "block[id=25](<self>: T.class_of(Main), <selfRestore>$163: T.class_of(Main), @a$121: T.untyped, @@b$125: T.untyped, $c$129: T.untyped)\louterLoops: 1\l<self>: T.class_of(Main) = loadSelf\l<blk>$164: T.untyped = load_yield_params(each)\lforTemp$6: T.untyped = <blk>$164\l<assignTemp>$15$6: T.untyped = forTemp$6: T.untyped.to_a()\l<statTemp>$171: T.class_of(<Magic>) = alias <C <Magic>>\l<statTemp>$173: Integer(5) = 5\l<statTemp>$174: Integer(0) = 0\l<assignTemp>$16$6: T.untyped = <statTemp>$171: T.class_of(<Magic>).<expand-splat>(<assignTemp>$15$6: T.untyped, <statTemp>$173: Integer(5), <statTemp>$174: Integer(0))\l<statTemp>$177: Integer(0) = 0\l@a$121: T.untyped = <assignTemp>$16$6: T.untyped.[](<statTemp>$177: Integer(0))\l<statTemp>$180: Integer(1) = 1\l@@b$125: T.untyped = <assignTemp>$16$6: T.untyped.[](<statTemp>$180: Integer(1))\l<statTemp>$183: Integer(2) = 2\l$c$129: T.untyped = <assignTemp>$16$6: T.untyped.[](<statTemp>$183: Integer(2))\l<statTemp>$186: Integer(3) = 3\ld$6: T.untyped = <assignTemp>$16$6: T.untyped.[](<statTemp>$186: Integer(3))\l<statTemp>$188: T.class_of(E) = alias <C E>\l<statTemp>$191: Integer(4) = 4\l<statTemp>$189: T.untyped = <assignTemp>$16$6: T.untyped.[](<statTemp>$191: Integer(4))\l<statTemp>$187: T.untyped = <statTemp>$188: T.class_of(E).e=(<statTemp>$189: T.untyped)\l<statTemp>$194: T.untyped = @a$121: T.untyped.inspect()\l<statTemp>$192: NilClass = <self>: T.class_of(Main).puts(<statTemp>$194: T.untyped)\l<statTemp>$198: T.untyped = @@b$125: T.untyped.inspect()\l<statTemp>$196: NilClass = <self>: T.class_of(Main).puts(<statTemp>$198: T.untyped)\l<statTemp>$202: T.untyped = $c$129: T.untyped.inspect()\l<statTemp>$200: NilClass = <self>: T.class_of(Main).puts(<statTemp>$202: T.untyped)\l<statTemp>$206: T.untyped = d$6: T.untyped.inspect()\l<statTemp>$204: NilClass = <self>: T.class_of(Main).puts(<statTemp>$206: T.untyped)\l<statTemp>$211: T.class_of(E) = alias <C E>\l<statTemp>$210: T.untyped = <statTemp>$211: T.class_of(E).e()\l<statTemp>$209: T.untyped = <statTemp>$210: T.untyped.inspect()\l<blockReturnTemp>$166: NilClass = <self>: T.class_of(Main).puts(<statTemp>$209: T.untyped)\l<blockReturnTemp>$212: T.noreturn = blockreturn<each> <blockReturnTemp>$166: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_25" -> "bb::<Class:Main>#main_22" [style="bold"];
}

}

